<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wave Shooter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing:border-box; }
    body { margin:0; background:#111; color:#eee; font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif; display:flex; flex-direction:column; align-items:center; }
    #game { border:2px solid #444; background:#000; display:block; margin-top:8px; }
    .overlay { position:fixed; top:8px; left:8px; background:rgba(0,0,0,.7); padding:8px 12px; border-radius:10px; font-size:14px; }
    .btn { background:#222; border:1px solid #555; padding:6px 12px; border-radius:8px; cursor:pointer; margin-right:6px; color:#eee; }
    .btn:hover { background:#333; }
    #controls { margin-top:6px; }
  </style>
</head>
<body>
  <h1 style="margin:8px 0;">Wave Shooter HTML Game</h1>
  <canvas id="game" width="480" height="640" aria-label="Wave shooter game"></canvas>
  <div id="controls">
    <button class="btn" id="startBtn">Start / Restart</button>
    <span style="margin-left:8px;">Move: Arrow keys / A,D. Shoot: Space</span>
  </div>
  <div class="overlay" id="status">Press Start</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let width = canvas.width; let height = canvas.height;

    // Game state
    let player, bullets, enemies, lastSpawn, wave, score, running, lastShot;

    function reset() {
      player = { x: width/2, y: height - 40, w: 24, h: 12, speed: 4, cooldown: 200 };
      bullets = [];
      enemies = [];
      lastSpawn = 0;
      wave = 1;
      score = 0;
      running = true;
      lastShot = 0;
      document.getElementById('status').textContent = 'Wave 1 - Score: 0';
    }

    function spawnWave(n) {
      const padding = 30;
      for (let i = 0; i < n; i++) {
        const cols = Math.min(n, 8);
        const row = Math.floor(i / cols);
        const col = i % cols;
        const x = padding + col * ((width - padding*2) / cols) + 10;
        const y = 40 + row * 40;
        enemies.push({ x, y, w:20, h:12, vx: 0.5 * ((wave%2)?1:-1), hp:1, sway: Math.random()*0.5, baseX:x });
      }
    }

    function update(dt) {
      if (!running) return;
      // Player input
      if (keys.ArrowLeft || keys.a) player.x -= player.speed;
      if (keys.ArrowRight || keys.d) player.x += player.speed;
      if (player.x < player.w/2) player.x = player.w/2;
      if (player.x > width - player.w/2) player.x = width - player.w/2;
      // Shooting
      if ((keys.Space || keys[' ']) && performance.now() - lastShot > player.cooldown) {
        bullets.push({ x: player.x, y: player.y - 10, r:4, vy:-6 });
        lastShot = performance.now();
      }
      // Update bullets
      bullets = bullets.filter(b => b.y > -10);
      bullets.forEach(b => { b.y += b.vy; });
      // Update enemies
      enemies.forEach(e => {
        // simple sway and horizontal movement
        e.x = e.baseX + Math.sin(performance.now() / 300 + e.sway) * 15;
        // drop slowly over time
        e.y += 0.02 * dt;
      });
      // Collision bullet-enemy
      bullets.forEach(b => {
        enemies.forEach(e => {
          if (Math.abs(b.x - e.x) < (e.w/2 + b.r) && Math.abs(b.y - e.y) < (e.h/2 + b.r)) {
            e.hp -= 1;
            b.dead = true;
            if (e.hp <= 0) { e.dead = true; score += 10; }
          }
        });
      });
      bullets = bullets.filter(b => !b.dead);
      enemies = enemies.filter(e => !e.dead);
      // Next wave
      if (enemies.length === 0 && performance.now() - lastSpawn > 500) {
        wave += 1;
        spawnWave(3 + wave * 2);
        lastSpawn = performance.now();
      }
      // Enemy reach bottom -> game over
      if (enemies.some(e => e.y + e.h/2 >= player.y - 4)) {
        running = false;
        document.getElementById('status').textContent = 'Game Over. Final Score: ' + score + ' (Wave ' + wave + ')';
      } else {
        document.getElementById('status').textContent = 'Wave ' + wave + ' - Score: ' + score;
      }
    }

    function draw() {
      // clear
      ctx.clearRect(0,0,width,height);
      // player
      ctx.fillStyle = '#0f0';
      ctx.fillRect(player.x - player.w/2, player.y - player.h/2, player.w, player.h);
      // bullets
      bullets.forEach(b => {
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
      });
      // enemies
      enemies.forEach(e => {
        ctx.fillStyle = '#f55';
        ctx.fillRect(e.x - e.w/2, e.y - e.h/2, e.w, e.h);
      });
    }

    let lastTime = performance.now();
    function loop() {
      const now = performance.now();
      const dt = now - lastTime;
      update(dt);
      draw();
      lastTime = now;
      requestAnimationFrame(loop);
    }

    // Input handling
    const keys = {};
    window.addEventListener('keydown', e => { keys[e.key] = true; if (['ArrowLeft','ArrowRight',' ','a','d'].includes(e.key)) e.preventDefault(); });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    document.getElementById('startBtn').addEventListener('click', () => { reset(); });

    // Resize to maintain crispness on high DPI
    function resizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      canvas.width = 480 * ratio;
      canvas.height = 640 * ratio;
      canvas.style.width = '480px';
      canvas.style.height = '640px';
      ctx.setTransform(ratio,0,0,ratio,0,0);
      width = 480; height = 640;
    }
    resizeCanvas();
    spawnWave(5);
    lastSpawn = performance.now();
    loop();

    // Accessibility: allow restarting with R
    window.addEventListener('keypress', e => { if (e.key.toLowerCase() === 'r') reset(); });
  </script>
</body>
</html>
